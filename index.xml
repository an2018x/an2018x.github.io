<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>安橙的博客</title><link>https://blog.ans20xx.com/</link><description>Recent content on 安橙的博客</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>&amp;copy; 2022 &lt;a href="https://www.ans20xx.com/">安橙&lt;/a></copyright><lastBuildDate>Sat, 12 Nov 2022 17:14:08 +0800</lastBuildDate><atom:link href="https://blog.ans20xx.com/index.xml" rel="self" type="application/rss+xml"/><item><title>业务开发的技术成长 11 订单领域设计及代码实践</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-11-%E8%AE%A2%E5%8D%95%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 12 Nov 2022 17:14:08 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-11-%E8%AE%A2%E5%8D%95%E9%A2%86%E5%9F%9F%E8%AE%BE%E8%AE%A1%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%AE%9E%E8%B7%B5/</guid><description>订单领域设计及代码实践
00:33
比较复杂的点：SKU 可能是动态的。
可以卖实体商品，也可以卖虚拟商品，也可以卖租赁系统。
02:12
阿里订单系统：
04:19
在考虑订单领域之前，先考虑用户领域，因为订单是和用户关联的。
用户可能有多个归属，可能有私人账号，也可能有企业账号，企业账号有企业绑定的信息。
用户能力是和账号绑定的，订单同样存储的是账号 id。
09:06
一个订单最终由什么支付组成 -&amp;gt; PayItem。
11:44
订单设计时考虑哪些东西？
所有订单必须有个唯一标识，就是订单流水号。
账号 id 和账号类型设计用户体系。
订单类型，新购、续费。。。。。
支付详情，包含支付项、还包含支付前的虚拟资产。
待支付金额。
订单信息通过列表来存储，每一项 CodeValue 实际上是一个 KV 对。
配送中等状态不属于订单领域，属于履约领域，订单只关心支付状态。
20:21
订单的生命周期。
生命周期会记录操作类型
21:00
修订和审计功能仍然在开发中，期待。
21:12
为什么要写领域服务层，因为我们的业务场景千变万化，有可能在后台下了个单，也有可能在前台下了个单。
领域服务提供了一个约束，即你想要下单，必须传入指定的参数。
在没有产品的情况下，是可以把通用领域层写完的。
26:36
我们可以根据订单类型的不同创建不同的索引，如果系统量很大，一定要创建不同的索引。
27:23
订单事件监听。
可以通过监听事件来处理保存、生命周期、同步 ES。
库表接口：
包含 3 个表：
order_base、order_item、order_lifecycle</description></item><item><title>业务开发的技术成长 10 出入库领域分析与代码实战</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-10-%E5%87%BA%E5%85%A5%E5%BA%93%E9%A2%86%E5%9F%9F%E5%88%86%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/</link><pubDate>Sat, 12 Nov 2022 15:12:38 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-10-%E5%87%BA%E5%85%A5%E5%BA%93%E9%A2%86%E5%9F%9F%E5%88%86%E6%9E%90%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/</guid><description>出入库领域分析与代码实战
01:09
如何抽象资产，现实中可以对应一个商品。
商品可能最开始在一个京东仓库，京东还会有二仓，或者临时快递点，这时候就会设计出库和入库的过程。
如果用传统方式来写，会发现有个方法用来表示从总部到二仓，购买的时候又会调用一次。
对于资产来说（可以是商品，也可以是虚拟商品），从头到尾只有入库和出库两个操作。
通常，用一个状态值来描述出和入的动作。
出实际上就是这个商品在仓库中不能用了，将来如果退回来，又是可用了。
这就是领域对象的充血模型，我们在分析对象自身的行为动作。
如果入库了，就发布一个商品入库的事件。
05:46
对于单个商品来讲，我们是入库，然而在显示生活中，可能有一批商品入库。
InOutBizType 是业务行为的描述。
对资产来说，不关注谁进行了操作，所以可以发送一个事件。
注册事件后，会有一个事件监听器。
09:31
商品入库后，要添加出入库记录、更新库存、记录资产编码。
未来想要增加一个新的功能，就需要改资产的代码，这违背了开闭原则。
这里就需要领域开发中的概念：事件解耦。
最小知道原则：知道的越少，方法就越通用。
11:40
对于资产，无论是现实生活中资产的调拨、购买等。
领域服务分为应用-&amp;gt;领域服务层。
领域服务是对所有业务的抽象，无论上层怎么变，
17:28
所有出库入库都不是集体行为，而是单个行为。
每次单个出库入库都会发送一条事件，如何保证在批量出入库的时候不发送那么多的事件。
单个的行为累计到一起形成批次的概念，要考虑每一个都有单独的行为。
21:44
领域服务就是在应用层下提供一个抽象的更通用的服务。
28:28
数据库设计方面：
assert 存储库内资产：
assert_in_out_record 存储出入库记录：
入库的操作对应一个用户，但是对于资产来说，却没有对应任何一个用户。
assert_life_cycle
主要记录某一个资产出入库的所有记录。
可以用来进行生命周期的跟踪。</description></item><item><title>业务开发的技术成长 9 数据校验深入学习及如何高效进行学习</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-9-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0/</link><pubDate>Sat, 12 Nov 2022 10:31:29 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-9-%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E8%BF%9B%E8%A1%8C%E5%AD%A6%E4%B9%A0/</guid><description>数据校验深入学习及如何高效进行学习
00:29
Spring 的校验有两种方式，一种是在 Controller 上加 @Validated 注解，另一种是在方法参数上加 @Valid 注解。
@Validated 和 @Valid 的区别。
用 @Valid 和 @RequestBody 有很大的关系。
@Valid 会处理 @RequestBody，支持入参，也支持返参。
也可以自定义一个注解来进行校验。
04:02
后置处理器的作用是写一些注解，通过后置处理器拿到注解。
05:59
如果指定了组的话，会根据组进行校验。即同一个校验规则在不同的组下，有不同的校验规则。
23:08
学习方法：
引导学习，自己找一些兴趣点</description></item><item><title>业务开发的技术成长 8 领域开发产品录入代码演示</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-8-%E9%A2%86%E5%9F%9F%E5%BC%80%E5%8F%91%E4%BA%A7%E5%93%81%E5%BD%95%E5%85%A5%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA/</link><pubDate>Fri, 11 Nov 2022 21:53:53 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-8-%E9%A2%86%E5%9F%9F%E5%BC%80%E5%8F%91%E4%BA%A7%E5%93%81%E5%BD%95%E5%85%A5%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA/</guid><description>02:01
使用脚手架生成项目 -&amp;gt; 配置 Datasource -&amp;gt; 修改主类名 -&amp;gt; 启动项目。
07:52
先建立一个包 template，演示模板模块。
这个模块可以理解为一个动态的表单。
创建对象，这里 UP 使用了快捷键来一键生成模板。
CodeValue 属于一个通用模型，通常放在 infrastructure 包下面。
前端最好不要直接传枚举值，而是应该传整型。
22:02
好多项目里面都是用 JSON 存规则的。
如果数据量不到千万规则，都可以直接用 JSON 来维护。
在存储的时候直接存接口，因为这种规则描述信息太多了，不用这种方式没法存。
25:07
无论单体还是微服务，我们都有一个 Constants 包，可以存放错误码信息。
对于微服务而言，编码规则如下：
前两位数字表示应用类型（商城应用） 后两位表示应用对应拆分的服务（库存服务） 后三位表示错误类型 26:32
Hutool 包包含了不少有用的工具类。
commons-validator 用来校验。
29:01
不要再写 Setter 和 Getter 了，要用 default 方法来进行转换：
37:25
使用 Validator 对字段进行校验。
47:07
离生产代码的距离：
权限 校验 流量限流 防重 审计</description></item><item><title>业务开发的技术成长 7 如何更好的理解登录</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-7-%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3%E7%99%BB%E5%BD%95/</link><pubDate>Thu, 10 Nov 2022 22:09:53 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-7-%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E7%90%86%E8%A7%A3%E7%99%BB%E5%BD%95/</guid><description>如何更好的理解登录
01:06
框架问题实际上解决的是生活中的问题。
登录有两个很重要的概念：Principle(人) 和 Credential(密码、刷脸)。
权限领域主要是解决两大问题：Authentication（认证问题） 和 Authorization（授权问题）。
门票、刷脸等都可以被称为一个认证对象。
05:31
Authentication 是一个接口，接口对应一个抽象的令牌。
对一个门口，存在一个门卫，只处理工作证。
对另外一个门，可能存在一个门卫，只处理门票。
在 SpringSecurity 中，用 filter 来代表每一个入口。
Filter1 专门用来处理门票，Filter2 专门用来处理工作证，Filter3 专门用来处理指纹。
那假如一个人由一张票，那么应由谁来处理呢？由 Provider 来处理，即 Provider 对应认证处理 token。具体表现为每个 filter 找到对应处理的 provider 来处理。
12:28
每个 filter 都要去找 provider 会非常麻烦，有一个设计模式称为门面模式。
在程序中，通常使用 ProviderManager 来管理和协调。
除了 ProviderManager 外，还有一个 AuthenticationManager，用来找到 ProviderManager。
16:02
领域设计=面向对象设计
认证就是 Token -&amp;gt; filter -&amp;gt; provider。
授权也是如此，即把 provider 提供的结果放入上下文中。
对于授权，会有一个 AccessManager（访问控制器） 的概念，即授权认证通过了，需要根据上下文进行访问控制。
AccessManager 会抽象出一个 Voter（投票器）的概念。
Voter 执行多数通过策略或一致通过策略，这在代码中通常通过 @Securied 或 @PreAuth 注解来实现。
21:04
用户在输入用户名和密码在登录后会得到一个 token。
相当于用户看比赛中途想要到场外上厕所，这时候工作人员给用户颁发了一个临时通行证。</description></item><item><title>业务开发的技术成长 6 中间件建设之统一权限集成</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-6-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BB%BA%E8%AE%BE%E4%B9%8B%E7%BB%9F%E4%B8%80%E6%9D%83%E9%99%90%E9%9B%86%E6%88%90/</link><pubDate>Tue, 08 Nov 2022 22:09:53 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-6-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BB%BA%E8%AE%BE%E4%B9%8B%E7%BB%9F%E4%B8%80%E6%9D%83%E9%99%90%E9%9B%86%E6%88%90/</guid><description>中间件建设之统一权限集成
01:27
老系统会存在越权问题、权限管理混乱，没有同一的权限管理中心。
老系统如何迁移到新系统上？
如果所有应用都使用 SpringSecurity，发现套不上老系统。
02:14
需要从底层考虑权限这个东西，思考权限究竟是什么？处理的是什么？
以生活为例，假如说我要进入一个体育场。
这个体育场会根据你有没有门票、是不是公司的职员来判断让不让你进。
同时，体育场可能有后门，管理人员可以刷脸、刷指纹进入。
指纹、刷脸、门票、职员工作证。
在框架中，我们把这些概念抽象成两部分：Principle （代表唯一的个体/主题，确认唯一性）和 Credential（凭证）。
06:58
如果一个系统需要一个通用权限管理框架，我们需要思考这个框架要做什么。
Web 系统的需求是针对 url 给它们起一个唯一性的编码，在某些系统中被成为安全对象。
以体育场为例，观众拿着标号为 13 号的票就能在 13 号座位上坐下，代表座位的号码就是唯一性编码。
如果能访问这个 url，需要一个授权码。系统期望访问 url 时，能把用户和权限码的对应关系传递给它。
如果有了这种关系，就能控制对资源的访问。
这种关系我们可以存储到上下文中。
上下文应该存储的内容有：用户和权限的对应关系以及关于用户的额外信息。
只要这些通用功能集成的像插件一样，我们就可以把它们放在一些 starter 二方包中，从 starter 中获取上下文，并把额外信息放入上下文中。
14:08
权限从需求上来讲，就是那些 url 做控制、哪些不做，还有用户与权限的对应关系、用户的额外信息。
后面两点可以从任意地方去查，并放入上下文中，这也被叫做授权。
16:39
实现这些功能就是在应用之上构建一层 filter。
对于所有用户，开放了一个用户上下文接口，用来在登录认证时触发回调，并获取用户的相关信息：
17:56
对于登录，我们会有一个 SSO。
我们任何一个系统都会有一个认证中心，用户通过认证中心登录，并返回 token。
在访问其他系统时，都会携带这个 token，其他应用解析 token 时首先会查询认证中心，认证中心会返回用户和权限信息。
可以在接口上加上权限注解，那么只有上下文中包含该权限编码才能访问该接口。</description></item><item><title>业务开发的技术成长 5 中间件建设之通用文件集成</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BB%BA%E8%AE%BE%E4%B9%8B%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E9%9B%86%E6%88%90/</link><pubDate>Mon, 07 Nov 2022 22:29:24 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-5-%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%BB%BA%E8%AE%BE%E4%B9%8B%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E9%9B%86%E6%88%90/</guid><description>中间件建设之通用文件集成
00:02
服务目前分为两层，一层是 Service 层，提供领域服务。
上面一层是 Web 层，即应用层，包括数据校验、权限校验、文件处理、监控等。
00:42
在实际的开发中，我们需要考虑如何给 Web 层附加一些能力。
能力主要包含几个方面：权限集成、重复提交、分布式锁、审计功能。
01:48
对于整个通用的服务来讲，我需要考虑链路追踪。
链路追踪从上到下都要进行检测，链路追踪从网关到 Web 到 Service 的所有行为。我们通常使用中间件来集成这种能力，例如 APM、SkyWalking。
02:50
第二部分主要是分布式日志收集。
分布式日志收集的主要配置点有两个：
Maven 依赖 在 resource/logback-spring.xml 下配置 grpc-log appender： 03:35
分布式日志收集目前采用的是 grpc，会对性能产生一定的影响。
如果不想业务处理的时候上报，可以先打到本地磁盘，然后通过 logstash 完成各个机器的收集和上报，好处是对应用的侵入性低。
05:30
Web 应用还需要考虑文件处理。
Web 层是走 HTTP 协议的，前端访问的是一个文件地址，通过 Nginx 直接反向代理给它。
对于 Service 层，不走 HTTP，而是直接走文件流，例如，直接通过 OSS 走文件流读，
06:59
在 Web 层会有一个部署操作，这个操作实际上是将文件直接上传给 OSS。
在流程引擎 deploy 的时候，会直接拿到流进行 deploy 操作。
07:43
在系统中，我们会写一堆 starter。
例如 oss-starter，为了实现通用性。
oss 通常会选用阿里云、腾讯云，如果自己搭建的话，会选用 MINIO。
这些 OSS 都是走的 S3 (Simple Storage Service，简单存储服务) 协议。</description></item><item><title>业务开发的技术成长 4 代码生成器原理</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-4-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E5%8E%9F%E7%90%86/</link><pubDate>Sun, 06 Nov 2022 20:02:52 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-4-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E5%8E%9F%E7%90%86/</guid><description>代码生成器原理
00:33
SHOW TABLE STATUS FROM order_center; SHOW FULL COLUMNS FROM order_item; 第一句执行后，会将数据库下所有表都列出来，拿出指定的一行，将来转换成 Entity 第二句执行后，会将每个表中的属性详情查找出来 01:59
最简单的实现方式：数据库 -&amp;gt; 模板引擎。
可以通过 IDE 的 Live Template 实现。
03:55
DTO 代表的是前端的输入/输出，Entity 代表的是库表映射对象，简单的代码生成器只能应付 Entity 的情景（例如，is_deleted 字段显然不适合透传给前端），我们按照上面的方法生成的对象不可能直接对应到 DTO，也就是说，只能生成针对 DAO 层的东西。
如果只是单纯的减少某些变量，还是可以通过这种方法来处理，这里我们可以生成 Request 对象。
06:06
有些带页面的代码生成器会针对 Field 进行一些配置，例如增加一些校验规则。
对于面向数据库增删改查，这种操作已经足够了。但是，对于扩展性比较高的项目，这种方法有很大局限性。
07:04
Mybatis 最痛苦的一点是数据库的某些字段增减时，维护 Mapper 需要进行很多重复的工作。
JPA 封装了对数据库操作的抽象，也封装了对领域对象的抽象。
JPA 可以让我们不关心数据库，而是关心对象的建模，也就是说，根据对象的建模，把相应的 Mapper、Request 等对象都生成出来。
09:42
我们不把 DTO 对象命名为 DTO。
我们把 DTO 对象划分为 Request 和 Response 对象。
对数据库每张表的操作，我们把它们划分为 Creator 和 Updater 对象。
为了解决 Mabatis 增减对象时每次频繁修改对象，让数据表的状态更改只能通过 Service 方法进行，这样的好处是维护点的统一，将来能跟踪到任何一次状态的跟踪。</description></item><item><title>业务开发的技术成长 3 技术架构及如何快速开发技巧</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-3-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 06 Nov 2022 17:10:31 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-3-%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</guid><description>技术架构及如何快速开发技巧
02:28
每一个模块都是作为一个项目组进行开发。
02:53
部署架构描述：
02:57
首先有一个 GateWay，所有请求都会先打到 GateWay 上面。
GateWay 做一些限流、基本的权限认证。
03:30
GateWay 下面是一个 Web 层，Web 层可以分为多种 Web：
web 发票系统 web 支付管理平台 Web 的职责是聚合应用层，有权限控制。
权限控制包括数据权限和操作权限。
数据权限：类似于 SQL 加上一个 WHERE 操作权限： 04:23
下层就是 Service 层，职责是领域服务层，处理业务逻辑。
Service 层与 Web 层的区别是：Service 层不做权限，而 Web 层处理权限问题。
Service 层提供的是领域服务，例如：订单服务、用户服务。
07:13
命名都是基于这种部署特点。
命名规则如下，以 auth 模块为例，它被分为 3 个子模块：
auth-web auth-center-api auth-center 目前都是以后缀作为区别。
07:49
最终效果是我们会写出一些通用的领域服务，可以适配于多种场景。
08:11
我们的项目是如何快速开发的。
我们会抽象出几个概念：
Service 这层会使用一个代码生成器，它的特点是不需要考虑权限问题+只考虑领域建模，目前我们会基于一套脚手架。 op-archetypes 工程下给出了所有模板，也就是说模板已经都写好了，并处理了兼容性问题。
17:35
使用 live template 快速生成 User 类。
同时，编译项目，生成所有的增删改查代码。
此时，开发一个项目速度就很快了，只需要对实体进行建模，就可以利用代码生成器生成其他通用操作代码。</description></item><item><title>业务开发的技术成长 2 如何打造高效的学习环境</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-2-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</link><pubDate>Sun, 06 Nov 2022 16:55:47 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-2-%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E9%AB%98%E6%95%88%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/</guid><description>如何打造高效的学习环境
00:32
在阿里云注册一个云效账号。
阿里云效
阿里云效提供代码管理和知识仓库功能，目前免费，可以用来学习。
01:51
支持流水线，可以自动化部署，不用自己本机搭建占资源的 Jenkins。
05:31
阿里提供免费的云起实验室，可以白嫖机器。
最终的效果是有自己的代码管理仓库，有自己的私服，有流水线，一提交就能自动部署。
09:24
免密登录，将 SSH 公钥复制到实验室中，追加到 authorized_keys 文件中。</description></item><item><title>业务开发的技术成长 1 Maven 环境配置</title><link>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-1-maven-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</link><pubDate>Sun, 06 Nov 2022 16:03:57 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%B8%9A%E5%8A%A1%E5%BC%80%E5%8F%91%E7%9A%84%E6%8A%80%E6%9C%AF%E6%88%90%E9%95%BF-1-maven-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</guid><description>maven环境配置
Maven 当前仓库使用阿里免费的仓库进行发布，免去了自建 nexus 的麻烦。需要将 setting.xml 放在 ~/.m2 目录下。
开发一个简单应用时，只需要继承 spring-boot-parent 这个 POM 文件就足够了。
对于复杂项目，也需要有一个基础的 POM 文件。
这个基础的 POM 文件，需要处理例如 SpringCloud、SpringBoot 等基础体系。
02:54
Maven 还需要一个脚手架，根据脚手架命令直接生成项目。
03:31
也会使用 Maven 插件的功能，这里主要使用了几个代码生成器和打包插件。
04:42
代码生成器的作用是可以生成关于这个领域对象所有代码，例如 Service、DAO、Mapper、Request 等。
05:47
IDEA Setting 文件提供了几个模板。</description></item><item><title>整洁代码之注释篇</title><link>https://blog.ans20xx.com/posts/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E7%AC%94%E8%AE%B04/</link><pubDate>Tue, 01 Nov 2022 00:05:06 +0800</pubDate><guid>https://blog.ans20xx.com/posts/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E7%AC%94%E8%AE%B04/</guid><description>前言 只有代码能告诉你它做的事，它是唯一准确的。尽管有时候我们也需要注释，但是还是要尽量减少它们。
MockRequest request; private final String HTTP_DATE_REGEXP = &amp;quot;[SMTWF][a-z]{2}\\,\\s[0-9]{2}\\s[JSFMASOND][a-z]{2}\\s&amp;quot; + &amp;quot;[0-9]{4}\\s[0-9]{2}\\:[0-9]{2}\\:[0-9]{2}\\sGMT&amp;quot;; private Response response; private FitNessContext context; private FileResponder responder; private Locale saveLocale; // Example: &amp;quot;Tue, 02 Apr 2003 22:18:49 GMT&amp;quot; 上面这段代码说明了什么问题呢？仔细看最后一行注释，它本应该是放在 HTTP_DATE_REGEXP 附近的，可能是后续开发者在变更代码时没有注意到这行注释，从而在二者之间插入了其他代码，这就让注释具有了误导性。
4.1 注释不能美化糟糕的代码 看到糟糕代码的时候，首先应想到如何把代码弄干净，而不是通过注释来美化它。
带有少量注释的整洁而有表现力的代码，要比带有大量注释的零碎而复杂的代码好的多。
4.2 用代码来阐述 // Check to see if the employee is eligible for full benefits if ((employee.flags &amp;amp; HOURLY_FLAG) &amp;amp;&amp;amp; (employee.age &amp;gt; 65)) 上面的代码显然不如下面的代码简单明了：
if (employee.isEligibleForFullBenefits()) 很多时候，只需要创建一个描述了与注释所言同一事物的函数即可。
4.3 好注释 有些注释是必须的。但是，最好还是尽量不写注释。
4.3.1 法律信息 示例如下：
// Copyright (C) 2003,2004,2005 by Object Mentor, Inc.</description></item><item><title>Diagram Support</title><link>https://blog.ans20xx.com/posts/diagram-support/</link><pubDate>Wed, 31 Mar 2021 13:11:22 +0800</pubDate><guid>https://blog.ans20xx.com/posts/diagram-support/</guid><description>&lt;p>Eureka supports the rendering of diagrams by using Mermaid.&lt;/p></description></item><item><title>Math Support</title><link>https://blog.ans20xx.com/posts/math-support/</link><pubDate>Fri, 20 Nov 2020 22:52:56 +0800</pubDate><guid>https://blog.ans20xx.com/posts/math-support/</guid><description>&lt;p>Eureka supports the rendering of mathematical formulas by using KaTeX.&lt;/p></description></item><item><title>Chapter 1</title><link>https://blog.ans20xx.com/docs/example-doc/chapter-1/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://blog.ans20xx.com/docs/example-doc/chapter-1/</guid><description>&lt;p>This is chapter 1 of example doc.&lt;/p></description></item><item><title>Chapter 1</title><link>https://blog.ans20xx.com/docs/example-doc/nested-chapter/chapter-1/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://blog.ans20xx.com/docs/example-doc/nested-chapter/chapter-1/</guid><description>&lt;p>This is chapter 1 of nested chapter.&lt;/p></description></item><item><title>Chapter 2</title><link>https://blog.ans20xx.com/docs/example-doc/chapter-2/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://blog.ans20xx.com/docs/example-doc/chapter-2/</guid><description>&lt;p>This is chapter 2 of example doc.&lt;/p></description></item><item><title>Chapter 2</title><link>https://blog.ans20xx.com/docs/example-doc/nested-chapter/chapter-2/</link><pubDate>Fri, 16 Oct 2020 00:00:00 +0000</pubDate><guid>https://blog.ans20xx.com/docs/example-doc/nested-chapter/chapter-2/</guid><description>&lt;p>This is chapter 2 of nested chapter.&lt;/p></description></item><item><title>Featured Image</title><link>https://blog.ans20xx.com/posts/featured-image/</link><pubDate>Tue, 26 May 2020 00:00:00 +0000</pubDate><guid>https://blog.ans20xx.com/posts/featured-image/</guid><description>&lt;p>Maecenas maximus, elit in ornare porttitor, nisi eros hendrerit nisl, sed fermentum nulla urna blandit tellus.&lt;/p></description></item><item><title>Markdown Syntax Guide</title><link>https://blog.ans20xx.com/posts/markdown-syntax/</link><pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate><guid>https://blog.ans20xx.com/posts/markdown-syntax/</guid><description>&lt;p>This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.&lt;/p></description></item><item><title>Placeholder Text</title><link>https://blog.ans20xx.com/posts/placeholder-text/</link><pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate><guid>https://blog.ans20xx.com/posts/placeholder-text/</guid><description>&lt;p>Lorem est tota propiore conpellat pectoribus de pectora summo.&lt;/p></description></item><item><title>Emoji Support</title><link>https://blog.ans20xx.com/posts/emoji-support/</link><pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate><guid>https://blog.ans20xx.com/posts/emoji-support/</guid><description>&lt;p>Emoji can be enabled in a Hugo project in a number of ways.&lt;/p></description></item></channel></rss>