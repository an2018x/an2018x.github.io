<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>4-Maven 依赖作用域 | 安橙的博客</title><meta name=keywords content><meta name=description content="描述 Maven 依赖作用域"><meta name=author content><link rel=canonical href=https://blog.ans20xx.com/docs/java/maven/chapter-4/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.ans20xx.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://blog.ans20xx.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://blog.ans20xx.com/favicon-32x32.png><link rel=apple-touch-icon href=https://blog.ans20xx.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.ans20xx.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.ans20xx.com/docs/java/maven/chapter-4/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://blog.ans20xx.com/docs/java/maven/chapter-4/"><meta property="og:site_name" content="安橙的博客"><meta property="og:title" content="4-Maven 依赖作用域"><meta property="og:description" content="描述 Maven 依赖作用域"><meta property="og:locale" content="zh"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2023-02-04T10:15:46+08:00"><meta property="article:modified_time" content="2022-02-04T10:15:46+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="4-Maven 依赖作用域"><meta name=twitter:description content="描述 Maven 依赖作用域"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Docs","item":"https://blog.ans20xx.com/docs/"},{"@type":"ListItem","position":2,"name":"Java","item":"https://blog.ans20xx.com/docs/java/"},{"@type":"ListItem","position":3,"name":"Maven","item":"https://blog.ans20xx.com/docs/java/maven/"},{"@type":"ListItem","position":4,"name":"4-Maven 依赖作用域","item":"https://blog.ans20xx.com/docs/java/maven/chapter-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"4-Maven 依赖作用域","name":"4-Maven 依赖作用域","description":"描述 Maven 依赖作用域","keywords":[],"articleBody":"1. 概述 下面的内容将描述 Maven 的依赖作用域-它能帮助 Maven 解决间接依赖。 2. 间接依赖 Maven 中有两种形式的依赖：直接依赖和间接依赖。 直接依赖是我们在项目中显式声明的依赖，例如： junit junit 4.12 间接依赖就是直接依赖的依赖。 Maven 会自动导入项目中的间接依赖。 可以使用 mvn dependency:tree 来列出项目中的所有依赖： [INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ demo01 --- [INFO] com.ans20xx:demo01:jar:1.0-SNAPSHOT [INFO] \\- junit:junit:jar:4.11:test [INFO] \\- org.hamcrest:hamcrest-core:jar:1.3:test [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 0.566 s [INFO] Finished at: 2023-02-04T09:33:56+08:00 [INFO] ------------------------------------------------------------------------ 3. 依赖作用域 依赖作用域可以被用来限制间接依赖。 依赖作用域也会根据不同的构建任务来修改 classpath。 Maven 有六种依赖作用域。 除了 import 作用域之外的其他作用域都会对间接依赖产生影响。 3.1. compile 作用域 当没有显式指定作用域时，compile 是默认的作用域。 在该作用域上的依赖会出现在所有的构建任务中的 classpath 内。 这些依赖也会被传递给子项目。 3.2. provided 作用域 使用 provided 作用域表示该依赖在运行时由 JDK 或容器提供。 该作用域的一个使用例子是在容器中部署 web 应用，而这些容器本身也提供了一些依赖，例如 tomcat 容器本身会提供 servlet api。 javax.servlet javax.servlet-api 4.0.1 provided provided 作用域的依赖值存在与 compile 和 test 的 classpath 中，在打包时并不会打到包中。 该作用域的依赖不可传递。 3.3. Runtime 作用域 该作用域下的依赖在运行时需要，但是我们在编译期不需要。 所以，该作用域下的依赖会出现在运行时和测试的 classpath 中，但不会出现在编译时的 classpath 中。 jdk 驱动就是运行时需要的依赖： mysql mysql-connector-java 8.0.28 runtime 3.4. Test 作用域 该作用域用来说明依赖只有在测试时才需要。 测试作用域下的依赖是不可传递的，只出现在 test 和 execution classpath 中。 JUnit 是一个典型的例子： junit junit 4.12 test 3.5. System 作用域 System 作用域和 Provided 作用域非常类似。 区别在于 System 作用域需要我们直接指定系统中的某个指定的 jar 包。 然而，需要注意的是 System 作用域已经被废弃了，因为它会让在不同机器上指定的值都不相同。 com.baeldung custom-dependency 1.3.2 system ${project.basedir}/libs/custom-dependency-1.3.2.jar 3.6. Import 作用域 import 作用域仅适用于 pom 类型的依赖。 import 说明该依赖应该被替换为声明在该 pom 文件中的所有有效依赖。 下面的例子中，customer-project 依赖会被替换为在 customer-project 的 pom 文件中 元素内的所有依赖： com.baeldung custom-dependency 1.3.2 system ${project.basedir}/libs/custom-dependency-1.3.2.jar 4. 作用域和传递性 每个依赖作用域都会影响间接依赖。 也就是说，间接依赖最终会以不同的作用域出现在项目中。 然而，provided 和 test 作用域的依赖并不会被包含在主项目中。 对于 compile 作用域，所有 runtime 作用域的依赖将会以 runtime 作用域被添加到项目中，所有 compile 作用域的依赖将会以 compile 作用域被添加到项目中。 对于 provided 作用域，所有 runtime 和 compile 作用域的依赖都会以 provided 作用域被添加到项目中。 对于 test 作用域，所有 runtime 和 compile 作用域的依赖都会以 test 作用域添加到项目中。 对于 runtime 作用域，所有 runtime 和 compile 作用域的依赖都会以 runtime 作用域添加到项目中。 https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html\n","wordCount":"1039","inLanguage":"zh","datePublished":"2023-02-04T10:15:46+08:00","dateModified":"2022-02-04T10:15:46+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.ans20xx.com/docs/java/maven/chapter-4/"},"publisher":{"@type":"Organization","name":"安橙的博客","logo":{"@type":"ImageObject","url":"https://blog.ans20xx.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.ans20xx.com/ accesskey=h title="安橙的博客 (Alt + H)">安橙的博客</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://blog.ans20xx.com/#about title=关于我><span>关于我</span></a></li><li><a href=https://blog.ans20xx.com/posts/ title=博文><span>博文</span></a></li><li><a href=https://blog.ans20xx.com/docs/ title=文档><span>文档</span></a></li><li><a href=https://blog.ans20xx.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.ans20xx.com/categories/ title=归档><span>归档</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">4-Maven 依赖作用域</h1><div class=post-description>描述 Maven 依赖作用域</div><div class=post-meta><span title='2023-02-04 10:15:46 +0800 +0800'>二月 4, 2023</span></div></header><div class=post-content><h2 id=1-概述>1. 概述<a hidden class=anchor aria-hidden=true href=#1-概述>#</a></h2><ol><li>下面的内容将描述 Maven 的依赖作用域-它能帮助 Maven 解决间接依赖。</li></ol><h2 id=2-间接依赖>2. 间接依赖<a hidden class=anchor aria-hidden=true href=#2-间接依赖>#</a></h2><ol><li>Maven 中有两种形式的依赖：直接依赖和间接依赖。</li><li>直接依赖是我们在项目中显式声明的依赖，例如：</li></ol><pre><code class=language-xml>&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><ol start=3><li>间接依赖就是直接依赖的依赖。</li><li>Maven 会自动导入项目中的间接依赖。</li><li>可以使用 <code>mvn dependency:tree</code> 来列出项目中的所有依赖：</li></ol><pre><code class=language-shell>[INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ demo01 ---
[INFO] com.ans20xx:demo01:jar:1.0-SNAPSHOT
[INFO] \- junit:junit:jar:4.11:test
[INFO]    \- org.hamcrest:hamcrest-core:jar:1.3:test
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  0.566 s
[INFO] Finished at: 2023-02-04T09:33:56+08:00
[INFO] ------------------------------------------------------------------------
</code></pre><h2 id=3-依赖作用域>3. 依赖作用域<a hidden class=anchor aria-hidden=true href=#3-依赖作用域>#</a></h2><ol><li>依赖作用域可以被用来限制间接依赖。</li><li>依赖作用域也会根据不同的构建任务来修改 classpath。</li><li>Maven 有六种依赖作用域。</li><li>除了 <code>import</code> 作用域之外的其他作用域都会对间接依赖产生影响。</li></ol><h2 id=31-compile-作用域>3.1. compile 作用域<a hidden class=anchor aria-hidden=true href=#31-compile-作用域>#</a></h2><ol><li>当没有显式指定作用域时，<code>compile</code> 是默认的作用域。</li><li>在该作用域上的依赖会出现在所有的构建任务中的 classpath 内。</li><li>这些依赖也会被传递给子项目。</li></ol><h2 id=32-provided-作用域>3.2. provided 作用域<a hidden class=anchor aria-hidden=true href=#32-provided-作用域>#</a></h2><ol><li>使用 provided 作用域表示该依赖在运行时由 JDK 或容器提供。</li><li>该作用域的一个使用例子是在容器中部署 web 应用，而这些容器本身也提供了一些依赖，例如 tomcat 容器本身会提供 servlet api。</li></ol><pre><code class=language-xml>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><ol start=3><li><code>provided</code> 作用域的依赖值存在与 compile 和 test 的 classpath 中，在打包时并不会打到包中。</li><li>该作用域的依赖不可传递。</li></ol><h2 id=33-runtime-作用域>3.3. Runtime 作用域<a hidden class=anchor aria-hidden=true href=#33-runtime-作用域>#</a></h2><ol><li>该作用域下的依赖在运行时需要，但是我们在编译期不需要。</li><li>所以，该作用域下的依赖会出现在运行时和测试的 classpath 中，但不会出现在编译时的 classpath 中。</li><li>jdk 驱动就是运行时需要的依赖：</li></ol><pre><code class=language-xml>&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;8.0.28&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><h2 id=34-test-作用域>3.4. Test 作用域<a hidden class=anchor aria-hidden=true href=#34-test-作用域>#</a></h2><ol><li>该作用域用来说明依赖只有在测试时才需要。</li><li>测试作用域下的依赖是不可传递的，只出现在 test 和 execution classpath 中。</li><li>JUnit 是一个典型的例子：</li></ol><pre><code class=language-xml>&lt;dependency&gt;
    &lt;groupId&gt;junit&lt;/groupId&gt;
    &lt;artifactId&gt;junit&lt;/artifactId&gt;
    &lt;version&gt;4.12&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><h2 id=35-system-作用域>3.5. System 作用域<a hidden class=anchor aria-hidden=true href=#35-system-作用域>#</a></h2><ol><li>System 作用域和 Provided 作用域非常类似。</li><li>区别在于 System 作用域需要我们直接指定系统中的某个指定的 jar 包。</li><li>然而，需要注意的是 System 作用域已经被废弃了，因为它会让在不同机器上指定的值都不相同。</li></ol><pre><code class=language-xml>&lt;dependency&gt;
    &lt;groupId&gt;com.baeldung&lt;/groupId&gt;
    &lt;artifactId&gt;custom-dependency&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;
    &lt;systemPath&gt;${project.basedir}/libs/custom-dependency-1.3.2.jar&lt;/systemPath&gt;
&lt;/dependency&gt;
</code></pre><h2 id=36-import-作用域>3.6. Import 作用域<a hidden class=anchor aria-hidden=true href=#36-import-作用域>#</a></h2><ol><li><code>import</code> 作用域仅适用于 pom 类型的依赖。</li><li><code>import</code> 说明该依赖应该被替换为声明在该 pom 文件中的所有有效依赖。</li><li>下面的例子中，<code>customer-project</code> 依赖会被替换为在 customer-project 的 pom 文件中 <code>&lt;dependencyManagement></code> 元素内的所有依赖：</li></ol><pre><code class=language-xml>&lt;dependency&gt;
    &lt;groupId&gt;com.baeldung&lt;/groupId&gt;
    &lt;artifactId&gt;custom-dependency&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;scope&gt;system&lt;/scope&gt;
    &lt;systemPath&gt;${project.basedir}/libs/custom-dependency-1.3.2.jar&lt;/systemPath&gt;
&lt;/dependency&gt;
</code></pre><h2 id=4-作用域和传递性>4. 作用域和传递性<a hidden class=anchor aria-hidden=true href=#4-作用域和传递性>#</a></h2><ol><li>每个依赖作用域都会影响间接依赖。</li><li>也就是说，间接依赖最终会以不同的作用域出现在项目中。</li><li>然而，<code>provided</code> 和 <code>test</code> 作用域的依赖并不会被包含在主项目中。</li><li>对于 compile 作用域，所有 runtime 作用域的依赖将会以 runtime 作用域被添加到项目中，所有 compile 作用域的依赖将会以 compile 作用域被添加到项目中。</li><li>对于 provided 作用域，所有 runtime 和 compile 作用域的依赖都会以 provided 作用域被添加到项目中。</li><li>对于 test 作用域，所有 runtime 和 compile 作用域的依赖都会以 test 作用域添加到项目中。</li><li>对于 runtime 作用域，所有 runtime 和 compile 作用域的依赖都会以 runtime 作用域添加到项目中。</li></ol><p><a href=https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html>https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>© 2022 <a href=https://www.ans20xx.com/>安橙</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>