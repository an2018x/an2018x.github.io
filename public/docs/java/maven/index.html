<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>Maven | 安橙的博客</title>
<meta name="keywords" content="">
<meta name="description" content="描述如何使用 Apache Maven">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/docs/java/maven/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="http://localhost:1313/docs/java/maven/index.xml">
<link rel="alternate" hreflang="zh" href="http://localhost:1313/docs/java/maven/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="安橙的博客 (Alt + H)">安橙的博客</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/#about" title="关于我">
                    <span>关于我</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/posts/" title="博文">
                    <span>博文</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/docs/" title="文档">
                    <span>文档</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="归档">
                    <span>归档</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Maven
  </h1>
  <div class="post-description">
    描述如何使用 Apache Maven
  </div>
</header>
<div class="post-content"><p>描述如何使用 Apache Maven</p>


</div>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">5-Maven 插件管理
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 概述 Maven 利用插件来自动化和执行所有的构建和生成报告的任务。 然而，项目中可能由多个相同的插件，它们的配置和版本都不一样，特别在多模块的项目中，这会让项目变得复杂，难以维护。 2. 插件配置 Maven 有两种类型的插件： Build - 在构建过程中执行，例如 Clean、Install 和 Surefire 插件，这些插件应该被配置在 pom 文件的 build 部分。 Reporting - 在 site 阶段执行来生成多个项目报告，例如 Javadoc 和 Checkstyle 插件，这些在 pom 文件的 reporting 部分配置。 我们可以在 pom 文件中声明 jar 插件，用来将我们的项目打包成 jar 文件： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 3. 插件管理 我们也可以在 pluginManagement 标签内声明插件。 如果在 pluginManagement 标签内声明插件，它将会对所有的子 POM 文件生效。 这意味着在子 pom 文件中不需要显示指定版本号，同时也不会有重复的配置或冲突的版本。 和依赖管理一样，在多模块项目中使用该方法非常有用。 4. 示例 下面是一个包含两个子模块的多模块项目。 在父 POM 文件中，我们添加了 Build Helper 插件。 4.1. 父 POM 文件 首先，在父 POM 文件的 pluginManagement 部分添加插件 该插件将 add-resource 目标绑定到 generate-resources 阶段 同样，我们也指定 src/resources 目录作为包含额外资源的目录 该插件会将资源拷贝到目标位置 &lt;pluginManagement&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;add-resource&lt;/id&gt; &lt;phase&gt;generate-resources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;add-resource&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/resources&lt;/directory&gt; &lt;targetPath&gt;json&lt;/targetPath&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; 4.2. 子 POM 配置 现在在子 POM 文件中引用该插件： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 和依赖管理相似，我们不需要指定任何插件的版本号，因为它们会从父 POM 文件中集成。 5. 核心插件 有一些 Maven 核心配置在整个生命周期中被默认使用，例如 clean 和 compiler 插件不需要被显式指定。 然而我们可以在 pluginManagement 中显式指定这些信息。 主要的区别在于核心插件默认会生效并自动执行，并不需要在子项目中传递引用。 下面我们在 pluginManage 中添加编译插件： &lt;pluginManagement&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.10.0&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/pluginManagement&gt; 这里我们锁定了插件的版本号，并且配置使用 Java 8 来构建项目，然而我们并不需要在子项目中额外声明插件。 构建框架默认激活这些配置。 因此，推荐在多模块项目中在 pluginManagement 中显式指定插件的配置并且锁定插件的版本。 </p>
  </div>
  <footer class="entry-footer"><span title='2023-02-04 10:30:46 +0800 CST'>二月 4, 2023</span></footer>
  <a class="entry-link" aria-label="post link to 5-Maven 插件管理" href="http://localhost:1313/docs/java/maven/chapter-5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">6-Maven 目标和阶段
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 概述 本文将会探索不同的 Maven 构建声明周期和它们的阶段。 也会深入讨论目标和阶段之间的核心关联。 2. Maven 构建生命周期 Maven 构建遵循一个指定的生命周期来部署和分发目标项目 有三种内置的生命周期： 默认(default)：主生命周期，负责项目的部署。 清理(clean)：清理项目并且移除所有由先前的构建产生的文件。 建立站点(site)：创建整个项目的文档 每个生命周期由若干个阶段(phase)组成，默认的构建生命周期包含 23 个阶段 clean 生命周期包含三个阶段，site 生命周期包含 4 个阶段 3. Maven 阶段 一个 Maven 阶段代表 Maven 构建生命周期其中的一个步骤。 每一个阶段都代表一个指定的任务。 默认生命周期下关键的一些阶段如下： validate：检查所有供构建需要的必要信息都足够完备 compile：编译源代码 test-compile：编译测试源代码 test：运行单元测试 package：将编译后的源代码进行打包 integration-test：如果需要运行集成测试，则处理和部署包 install：将包安装到本地仓库 deploy：将包复制到远程仓库 阶段按照指定的顺序指定，也就是说，如果我们执行命令 mvn &lt;phase&gt; 那么它不仅仅会只执行指定的阶段，也会执行前置的所有阶段。 例如，如果我们运行部署阶段，那么它会执行之前的所有完整阶段 4. Maven 目标(Goal) 每一个阶段都是由一系列目标构成的，每一个阶段都对应一个指定的任务。 当我们执行一个阶段时，所有绑定到该阶段上的目标都被按顺序执行（在 POM 文件中定义的顺序）。 下面是一些阶段和该阶段上绑定的默认的目标 compiler:compile：编译插件上的编译目标被绑定到编译阶段 compiler:testCompile: 被绑定到 test-compile 阶段 surefire:test: 被绑定到 test 阶段 install: 被绑定到 install 阶段 jar:jar 和 war:war： 被绑定到 package 阶段 可以使用命令 mvn help:describe -Dcmd=PHASENAME 来列出绑定到某一个阶段的目标和插件 5. Maven 插件 Maven 插件是一组目标，然而这些目标不必绑定到相同的阶段。 例如，下面是 Maven Failsafe 插件的简单配置，它被用来执行集成测试： &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-failsafe-plugin&lt;/artifactId&gt; &lt;version&gt;${maven.failsafe.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;integration-test&lt;/goal&gt; &lt;goal&gt;verify&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 可以看到，Failsafe 插件配置了两个主要的目标：
...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-04 10:30:46 +0800 CST'>二月 4, 2023</span></footer>
  <a class="entry-link" aria-label="post link to 6-Maven 目标和阶段" href="http://localhost:1313/docs/java/maven/chapter-6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">7-Maven 多模块项目
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 概述 本文主要描述 Maven 多模块项目如何创建。 描述什么是多模块项目以及使用该方法的好处。 2. Maven 的多模块项目 一个多模块项目根据一个聚合 pom 文件构建，该文件管理一组子模块。 在大多数情况下，聚合 pom 文件位于项目的根目录下，并且打包方式为 pom。 子模块是常规的 Maven 项目，并且它们也能被单独构建。 通过聚合 POM 来构建项目，每个打包方式不为 pom 的项目都会被打包进最终的项目文件中。 3. 使用多模块的好处 最显著的好处是我们能够减少重复和冲突。 假设我们有包含若干个模块的应用程序，一个前端模块和一个后端模块。 现在想象我们在它们之上构建项目，并且修改配置对二者都生效的配置项，使用多模块就很容易办到。 4. 父 POM Maven 通过让每个 pom 文件都有父 pom 文件来支持继承。 除了继承，Maven 还提供了聚合的概念，一个支持聚合的父 POM 文件被称为聚合 POM，这种 POM 在它的 pom 文件中声明聚合的模块。 5. 子模块 子模块，或者子项目，是继承自父 POM 文件的常规项目。 继承可以让子项目共享配置和依赖。 然而，如果我们想要一起编译和发布项目，就必须要在父 POM 文件中显式声明。 6. 构建应用程序 现在我们创建一个程序来演示这项功能，该程序包含三个模块：
...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-04 10:30:46 +0800 CST'>二月 4, 2023</span></footer>
  <a class="entry-link" aria-label="post link to 7-Maven 多模块项目" href="http://localhost:1313/docs/java/maven/chapter-7/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">4-Maven 依赖作用域
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 概述 下面的内容将描述 Maven 的依赖作用域-它能帮助 Maven 解决间接依赖。 2. 间接依赖 Maven 中有两种形式的依赖：直接依赖和间接依赖。 直接依赖是我们在项目中显式声明的依赖，例如： &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; 间接依赖就是直接依赖的依赖。 Maven 会自动导入项目中的间接依赖。 可以使用 mvn dependency:tree 来列出项目中的所有依赖： [INFO] --- maven-dependency-plugin:2.8:tree (default-cli) @ demo01 --- [INFO] com.ans20xx:demo01:jar:1.0-SNAPSHOT [INFO] \- junit:junit:jar:4.11:test [INFO] \- org.hamcrest:hamcrest-core:jar:1.3:test [INFO] ------------------------------------------------------------------------ [INFO] BUILD SUCCESS [INFO] ------------------------------------------------------------------------ [INFO] Total time: 0.566 s [INFO] Finished at: 2023-02-04T09:33:56&#43;08:00 [INFO] ------------------------------------------------------------------------ 3. 依赖作用域 依赖作用域可以被用来限制间接依赖。 依赖作用域也会根据不同的构建任务来修改 classpath。 Maven 有六种依赖作用域。 除了 import 作用域之外的其他作用域都会对间接依赖产生影响。 3.1. compile 作用域 当没有显式指定作用域时，compile 是默认的作用域。 在该作用域上的依赖会出现在所有的构建任务中的 classpath 内。 这些依赖也会被传递给子项目。 3.2. provided 作用域 使用 provided 作用域表示该依赖在运行时由 JDK 或容器提供。 该作用域的一个使用例子是在容器中部署 web 应用，而这些容器本身也提供了一些依赖，例如 tomcat 容器本身会提供 servlet api。 &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; provided 作用域的依赖值存在与 compile 和 test 的 classpath 中，在打包时并不会打到包中。 该作用域的依赖不可传递。 3.3. Runtime 作用域 该作用域下的依赖在运行时需要，但是我们在编译期不需要。 所以，该作用域下的依赖会出现在运行时和测试的 classpath 中，但不会出现在编译时的 classpath 中。 jdk 驱动就是运行时需要的依赖： &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; 3.4. Test 作用域 该作用域用来说明依赖只有在测试时才需要。 测试作用域下的依赖是不可传递的，只出现在 test 和 execution classpath 中。 JUnit 是一个典型的例子： &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 3.5. System 作用域 System 作用域和 Provided 作用域非常类似。 区别在于 System 作用域需要我们直接指定系统中的某个指定的 jar 包。 然而，需要注意的是 System 作用域已经被废弃了，因为它会让在不同机器上指定的值都不相同。 &lt;dependency&gt; &lt;groupId&gt;com.baeldung&lt;/groupId&gt; &lt;artifactId&gt;custom-dependency&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/libs/custom-dependency-1.3.2.jar&lt;/systemPath&gt; &lt;/dependency&gt; 3.6. Import 作用域 import 作用域仅适用于 pom 类型的依赖。 import 说明该依赖应该被替换为声明在该 pom 文件中的所有有效依赖。 下面的例子中，customer-project 依赖会被替换为在 customer-project 的 pom 文件中 &lt;dependencyManagement&gt; 元素内的所有依赖： &lt;dependency&gt; &lt;groupId&gt;com.baeldung&lt;/groupId&gt; &lt;artifactId&gt;custom-dependency&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;${project.basedir}/libs/custom-dependency-1.3.2.jar&lt;/systemPath&gt; &lt;/dependency&gt; 4. 作用域和传递性 每个依赖作用域都会影响间接依赖。 也就是说，间接依赖最终会以不同的作用域出现在项目中。 然而，provided 和 test 作用域的依赖并不会被包含在主项目中。 对于 compile 作用域，所有 runtime 作用域的依赖将会以 runtime 作用域被添加到项目中，所有 compile 作用域的依赖将会以 compile 作用域被添加到项目中。 对于 provided 作用域，所有 runtime 和 compile 作用域的依赖都会以 provided 作用域被添加到项目中。 对于 test 作用域，所有 runtime 和 compile 作用域的依赖都会以 test 作用域添加到项目中。 对于 runtime 作用域，所有 runtime 和 compile 作用域的依赖都会以 runtime 作用域添加到项目中。 https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html
...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-04 10:15:46 +0800 CST'>二月 4, 2023</span></footer>
  <a class="entry-link" aria-label="post link to 4-Maven 依赖作用域" href="http://localhost:1313/docs/java/maven/chapter-4/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">3-Maven Profile
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 概述 Maven Profile 可以被用来创建自定义的构建配置，例如指定一个测试粒度，或者是指定部署环境。
2. 简单例子 通常，我们运行 mvn package，单元测试也会被执行，如果我们不希望执行单元测试，可以使用如下的 profile 配置： &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;no-tests&lt;/id&gt; &lt;properties&gt; &lt;maven.test.skip&gt;true&lt;/maven.test.skip&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 然后通过命令 mvn package -Pno-tests 来执行该 profile。 现在工程被打包，并且测试也被跳过了。 3. 声明 Profiles 通过指定不同的 id，我们可以创建无数个 profile。 我们可以创建一个 profile 来运行集成测试，也可以定义另一个 profile 来运行变异测试。 &lt;profiles&gt; &lt;profile&gt; &lt;id&gt;integration-tests&lt;/id&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;mutation-tests&lt;/id&gt; &lt;/profile&gt; &lt;/profiles&gt; 在每一个 profile 元素内，我们可以配置许多元素，例如 dependencies，plugins，resources 和 finalName。 所以对上面的例子，我们可以对两个 profile 分别添加依赖和插件。 3.1. profile 作用域 之前，我们仅仅把 profiles 元素放在了 pom.xml 文件中，这样只会对该项目有效。 但是在 Maven 3 中，我们可以在如下位置添加 profiles： 项目范围：pom.xml 文件 用户范围：用户目录下的 settings.xml 文件 全局范围：全局 settings.xml 文件 4. 激活 Profile 4.1. 查看那个 profile 被激活 可以使用 help:active-profiles 来查询在我们默认的构建流程中，哪个 profile 被激活，一般情况下，查询结果为空。 另一种查看方式是将 maven-help-plugin 插件添加到 pom.xml 中，然后将其绑定到构建阶段下的 active-profile 目标上。 &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-help-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;show-profile&lt;/id&gt; &lt;phase&gt;compile&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;active-profiles&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 4.2 使用 -P 选项 我们可以使用 -P 选项来激活指定的 profile。 mvn package -P integration-tests 打印如下：
...</p>
  </div>
  <footer class="entry-footer"><span title='2023-02-01 15:15:46 +0800 CST'>二月 1, 2023</span></footer>
  <a class="entry-link" aria-label="post link to 3-Maven Profile" href="http://localhost:1313/docs/java/maven/chapter-3/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">2-Maven 标准目录结构
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 简介 Apache Maven 除了分离依赖和仓库外，还提供了一个标准的工程目录结构。
2. 目录结构 一个标准的 Maven 工程有一个 pom.xml 文件，还有一个基于约定的目录结构。 使用项目描述符可以覆盖默认的目录结构，但是不推荐。 3. 根目录 该目录作为每个 Maven 目录的根目录。 根目录下包含如下内容： pom.xml 定义 Maven 项目构建生命周期中需要的依赖和模块。 LICENSE.txt 描述项目的授权信息。 README.txt 项目的概要描述。 NOTICE.txt 该项目使用到的第三方库的名称。 src/main 包含工程中的源代码和资源 src/test 包含测试代码和资源 src/it 为 Maven Failsafe 的集成测试所保留 src/site 使用 Maven Site 插件创建的项目站点文档 src/assembly 打包所需要的集成配置 4. src/main 目录 src/main 目录是 Maven 项目中最重要的目录。 任何要被打包进 jar 或者 war 包中的内容都要被放在这里。 它的子目录如下： src/main/java 工程的 java 源代码 src/main/resources 配置文件和其他资源文件 src/main/webapp 对于 Web 应用，用来存放 JS、CSS、HTML、图片等文件 src/main/filters 包含一些配置文件，这些配置文件的作用是在编译时向 resource 中的文件注入值。 5. src/test 目录 src/test 目录存放着应用中每个模块的单元测试。 其中的任何资源或目录都不会被打包到最终的工程中。 它的子目录如下： src/test/java Java 测试源代码 src/test/resources 测试需要用的配置文件 src/test/filters 包含一些配置文件，这些配置文件的作用是在编译时向 resource 中的文件注入值。 </p>
  </div>
  <footer class="entry-footer"><span title='2023-01-29 15:15:46 +0800 CST'>一月 29, 2023</span></footer>
  <a class="entry-link" aria-label="post link to 2-Maven 标准目录结构" href="http://localhost:1313/docs/java/maven/chapter-2/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">1-Maven 简介
    </h2>
  </header>
  <div class="entry-content">
    <p>1. 构建应用程序 构建一个应用程序往往由以下几个步骤组成： 下载依赖 将依赖 jar 包放在 classpath 目录下 将源代码编译为二进制码 运行测试 将编译结果打包成可部署的软件包：jar、war 等 将工程发布到服务器或者仓库中 Apache Maven 将这些步骤自动化，减少了人工操作带来的错误 2. 为什么用 Maven Maven 有如下优势：
...</p>
  </div>
  <footer class="entry-footer"><span title='2022-11-29 15:15:46 +0800 CST'>十一月 29, 2022</span></footer>
  <a class="entry-link" aria-label="post link to 1-Maven 简介" href="http://localhost:1313/docs/java/maven/chapter-1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">
    </h2>
  </header>
  <div class="entry-content">
    <p></p>
  </div>
  <footer class="entry-footer"></footer>
  <a class="entry-link" aria-label="post link to " href="http://localhost:1313/docs/java/maven/chapter-8/"></a>
</article>
    </main>
    
<footer class="footer">
        <span>© 2022 <a href="https://www.ans20xx.com/">安橙</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
